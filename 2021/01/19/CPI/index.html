<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        Code-Pointer Integrity - BigBang019
        
    </title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/aircloud.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 5.3.0"></head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i>  </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>BigBang019</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Abstract"><span class="toc-text">Abstract</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Introduction"><span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Threat-Model"><span class="toc-text">Threat Model</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Design"><span class="toc-text">Design</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-The-Code-Pointer-Integrity-CPI-Property"><span class="toc-text">3.1 The Code-Pointer Integrity (CPI) Property</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-The-CPI-Enforcement-Mechanism"><span class="toc-text">3.2 The CPI Enforcement Mechanism</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-CPI-Static-Analysis"><span class="toc-text">3.2.1 CPI Static Analysis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-CPI-Instrumentation"><span class="toc-text">3.2.2 CPI Instrumentation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-Isolating-the-Safe-Region"><span class="toc-text">3.2.3 Isolating the Safe Region</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-The-Safe-Stack"><span class="toc-text">3.2.4 The Safe Stack</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-Code-Pointer-Separation-CPS"><span class="toc-text">3.3 Code-Pointer Separation (CPS)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Implementation"><span class="toc-text">Implementation</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i>  </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Code-Pointer Integrity
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2021-01-19 17:12:16</span></span>
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>Systems code is often written in low-level languages like C/C++, which offer many benefits but also delegate memory management to programmers. This invites memory safety bugs that attackers can exploit to divert control flow and compromise the system. Deployed defense mechanisms (e.g., ASLR, DEP) are incomplete, and stronger defense mechanisms (e.g., CFI) often have high overhead and limited guarantees [19, 15, 9]. We introduce code-pointer integrity (CPI), a new design point that guarantees the integrity of all code pointers in a program (e.g., function pointers, saved return addresses) and thereby prevents all control-flow hijack attacks, including return-oriented programming. We also introduce code-pointer separation (CPS), a relaxation of CPI with better performance properties. CPI and CPS offer substantially better security-to-overhead ratios than the state of the art, they are practical (we protect a complete FreeBSD system and over 100 packages like apache and postgresql), effective (prevent all attacks in the RIPE benchmark), and efficient: on SPEC CPU2006, CPS averages 1.2% overhead for C and 1.9% for C/C++, while CPI’s overhead is 2.9% for C and 8.4% for C/C++. A prototype implementation of CPI and CPS can be obtained from <a target="_blank" rel="noopener" href="http://levee.epfl.ch/">http://levee.epfl.ch</a>.</p>
<p>系统代码通常用C / C ++之类的低级语言编写，这提供了很多好处，但也将内存管理委托给程序员。这会引发内存安全漏洞，攻击者可以利用这些漏洞转移控制流并破坏系统。部署的防御机制（例如ASLR，DEP）是不完整的，而更强大的防御机制（例如CFI）通常具有较高的开销和有限的保证[19、15、9]。我们引入了代码指针完整性（CPI），这是一个新的设计点，可以保证程序中所有代码指针（例如，函数指针，保存的返回地址）的完整性，从而防止所有控制流劫持攻击，包括面向返回的编程。我们还引入了代码指针分隔（CPS），这是CPI的放松，具有更好的性能。 CPI和CPS提供的安全性与开销的比率比现有技术要好得多，它们是实用的（我们保护完整的FreeBSD系统以及超过100个软件包，如apache和postgresql），有效（防止RIPE基准测试中的所有攻击），高效：在SPEC CPU2006上，CPS的C开销平均为C，C / C ++的开销为1.9％，而CPI的C开销为2.9％，C / C ++则为8.4％。 CPI和CPS的原型实现可以从<a target="_blank" rel="noopener" href="http://levee.epfl.ch获得./">http://levee.epfl.ch获得。</a></p>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Systems code is often written in memory-unsafe languages; this makes it prone to memory errors that are the primary attack vector to subvert systems. Attackers exploit bugs, such as buffer overflows and use after free errors, to cause memory corruption that enables them to steal sensitive data or execute code that gives them control over a remote system [44, 37, 12, 8].</p>
<p>系统代码通常以内存不安全的语言编写； 这使得它容易产生内存错误，而内存错误是颠覆系统的主要攻击手段。 攻击者利用诸如缓冲区溢出之类的错误并在释放错误后使用错误，导致内存损坏，从而使他们能够窃取敏感数据或执行使他们能够控制远程系统的代码[44、37、12、8]。</p>
<p>Our goal is to secure systems code against all controlflow hijack attacks, which is how attackers gain remote control of victim systems. Low-level languages like C/C++ offer many benefits to system programmers, and we want to make these languages safe to use while preserving their benefits, not the least of which is performance. Before expecting any security guarantees from systems we must first secure their building blocks.</p>
<p>我们的目标是保护系统代码免受所有控制流劫持攻击的侵害，这是攻击者如何获得受害系统的远程控制。 诸如C / C ++之类的低级语言为系统程序员提供了许多好处，我们希望使这些语言安全使用，同时保留它们的好处，其中至少包括性能。 在期望系统提供任何安全保证之前，我们必须首先保护其构造块。</p>
<p>There exist a few protection mechanism that can reduce the risk of control-flow hijack attacks without imposing undue overheads. Data Execution Prevention (DEP) [48] uses memory page protection to prevent the introduction of new executable code into a running application. Unfortunately, DEP is defeated by code reuse attacks, such as return-to-libc [37] and return oriented programming (ROP) [44, 8], which can construct arbitrary Turing-complete computations by chaining together existing code fragments of the original application. Address Space Layout Randomization (ASLR) [40] places code and data segments at random addresses, making it harder for attackers to reuse existing code for execution. Alas, ASLR is defeated by pointer leaks, side channels attacks [22], and just-in-time code reuse attacks [45]. Finally, stack cookies [14] protect return addresses on the stack, but only against continuous buffer overflows.</p>
<p>存在一些保护机制，可以降低控制流劫持攻击的风险而又不会造成不必要的开销。 数据执行保护（DEP）[48]使用内存页保护来防止将新的可执行代码引入正在运行的应用程序中。 不幸的是，DEP被代码重用攻击所击败，例如return-to-libc [37]和面向返回的编程（ROP）[44，8]，它们可以通过将原始的现有代码片段链接在一起来构造任意的Turing-complete计算。 应用。 地址空间布局随机化（ASLR）[40]将代码和数据段放置在随机地址上，这使攻击者更难以重用现有代码来执行。 AS，ASLR被指针泄漏，边通道攻击[22]和即时代码重用攻击[45]击败。 最终，堆栈Cookie [14]保护了堆栈，但仅针对连续的缓冲区溢出。</p>
<p>Many defenses can improve upon these shortcomings but have not seen wide adoption because of the overheads they impose. According to a recent survey [46], these solutions are incomplete and bypassable via sophisticated attacks and/or require source code modifications and/or incur high performance overhead. These approaches typically employ language modifications [25, 36], compiler modifications [13, 3, 17, 34, 43], or rewrite machine code binaries [38, 54, 53]. Control-flow integrity protection (CFI) [1, 29, 53, 54, 39], a widely studied technique for practical protection against control-flow hijack attacks, was recently demonstrated to be ineffective [19, 15, 9].</p>
<p>许多防御措施可以改善这些缺点，但由于它们带来的间接费用，并未得到广泛采用。 根据最近的一项调查[46]，这些解决方案是不完整的，无法通过复杂的攻击绕过它们，并且/或者需要对源代码进行修改和/或产生高性能开销。 这些方法通常采用语言修改[25、36]，编译器修改[13、3、17、34、43]或重写机器代码二进制文件[38、54、53]。 控制流完整性保护（CFI）[1、29、53、54、39]是一种针对防控制流劫持攻击的实用保护措施，目前得到广泛研究，但效果不佳[19、15、9]。</p>
<p>Existing techniques cannot both guarantee protection against control-flow hijacks and impose low overhead and no changes to how the programmer writes code. For example, memory-safe languages guarantee that a memory object can only be accessed using pointers properly based on that specific object, which in turn makes control-flow hijacks impossible, but this approach requires runtime checks to verify the temporal and spatial correctness of pointer computations, which inevitably induces undue overhead, especially when retrofitted to memory-unsafe languages. For example, state-of-the-art memory safety implementations for C/C+ incur ≥ 2× 1148 11th USENIX Symposium on Operating Systems Design and Implementation (OSDI ’14) USENIX Association overhead [35]. We observe that, in order to render control-flow hijacks impossible, it is sufficient to guarantee the integrity of code pointers, i.e., those that are used to determine the targets of indirect control-flow transfers (indirect calls, indirect jumps, or returns).</p>
<p>现有技术既不能保证针对控制流劫持的保护，又不能带来低开销，并且不能改变程序员编写代码的方式。例如，内存安全语言保证只能基于特定对象使用指针正确访问内存对象，这又使控制流劫持成为不可能，但是这种方法需要运行时检查以验证指针的时间和空间正确性计算，不可避免地会引起不必要的开销，尤其是当改型为不安全的内存语言时。例如，最新的C / C +内存安全性实现≥2×1148，第11届USENIX操作系统设计和实现研讨会（OSDI ’14）USENIX协会开销[35]。我们观察到，为了使控制流劫持成为不可能，足以保证代码指针的完整性，即那些用于确定间接控制流传输（间接调用，间接跳转或返回）目标的指针）。</p>
<p>This paper introduces code-pointer integrity (CPI), a way to enforce precise, deterministic memory safety for all code pointers in a program. The key idea is to split process memory into a safe region and a regular region. CPI uses static analysis to identify the set of memory objects that must be protected in order to guarantee memory safety for code pointers. This set includes all memory objects that contain code pointers and all data pointers used to access code pointers indirectly. All objects in the set are then stored in the safe region, and the region is isolated from the rest of the address space (e.g., via hardware protection). The safe region can only be accessed via memory operations that are proven at compile time to be safe or that are safety-checked at runtime. The regular region is just like normal process memory: it can be accessed without runtime checks and, thus, with no overhead. In typical programs, the accesses to the safe region represent only a small fraction of all memory accesses (6.5% of all pointer operations in SPEC CPU2006 need protection). Existing memory safety techniques cannot efficiently protect only a subset of memory objects in a program, rather they require instrumenting all potentially dangerous pointer operations.</p>
<p>本文介绍了代码指针完整性（CPI），这是一种对程序中所有代码指针实施精确的确定性内存安全性的方法。关键思想是将过程内存分为安全区域和常规区域。 CPI使用静态分析来识别必须保护的一组内存对象，以确保代码指针的内存安全。该集合包括所有包含代码指针的内存对象和所有用于间接访问代码指针的数据指针。然后将集合中的所有对象存储在安全区域中，并将该区域与地址空间的其余部分隔离开（例如，通过硬件保护）。只能通过在编译时被证明是安全的或在运行时经过安全检查的存储器操作来访问安全区域。常规区域就像普通的进程内存一样：无需运行时检查即可访问它，因此没有开销。在典型程序中，对安全区域的访问仅占所有内存访问的一小部分（SPEC CPU2006中所有指针操作的6.5％需要保护）。现有的内存安全技术不能有效地仅保护程序中一部分存储对象，而是需要对所有潜在危险的指针操作进行检测。</p>
<p>CPI fully protects the program against all control-flow hijack attacks that exploit program memory bugs. CPI requires no changes to how programmers write code, since it automatically instruments pointer accesses at compile time. CPI achieves low overhead by selectively instrumenting only those pointer accesses that are necessary and sufficient to formally guarantee the integrity of all code pointers. The CPI approach can also be used for data, e.g., to selectively protect sensitive information like the process UIDs in a kernel.</p>
<p>CPI完全保护程序免受所有利用程序内存错误的控制流劫持攻击。 CPI不需要更改程序员编写代码的方式，因为它在编译时会自动检测指针访问。 CPI通过选择性地仅检测那些必须并足以正式保证所有代码指针的完整性的指针访问来实现较低的开销。 CPI方法也可以用于数据，例如，以选择性地保护敏感信息，例如内核中的进程UID。</p>
<p>We also introduce code-pointer separation (CPS), a relaxed variant of CPI that is better suited for code with abundant virtual function pointers. In CPS, all code pointers are placed in the safe region, but pointers used to access code pointers indirectly are left in the regular region (such as pointers to C++ objects that contain virtual functions). Unlike CPI, CPS may allow certain controlflow hijack attacks, but it still offers stronger guarantees than CFI and incurs negligible overhead.</p>
<p>我们还引入了代码指针分隔（CPS），这是CPI的一种宽松形式，它更适合于具有大量虚函数指针的代码。 在CPS中，所有代码指针都放置在安全区域中，但是用于间接访问代码指针的指针则保留在常规区域中（例如，指向包含虚拟函数的C ++对象的指针）。 与CPI不同，CPS可能允许某些控制流劫持攻击，但与CFI相比，它仍然提供更强大的保证，并且产生的开销可忽略不计。</p>
<p>Our experimental evaluation shows that our proposed approach imposes sufficiently low overhead to be deployable in production. For example, CPS incurs an average overhead of 1.2% on the C programs in SPEC CPU2006 and 1.9% for all C/C++ programs. CPI incurs on average 2.9% overhead for the C programs and 8.4% across all C/C++ SPEC CPU2006 programs. CPI and CPS are effective: they prevent 100% of the attacks in the RIPE benchmark and the recent attacks [19, 15, 9] that bypass CFI, ASLR, DEP, and all other Microsoft Windows protections. We compile and run with CPI/CPS a complete FreeBSD distribution along with ≥ 100 widely used packages, demonstrating that the approach is practical. This paper makes the following contributions:</p>
<ol>
<li>Definition of two new program properties that offer a security-benefit to enforcement-cost ratio superior to the state of the art: code-pointer integrity (CPI) guarantees control flow cannot be hijacked via memory bugs, and code-pointer separation (CPS) provides stronger security guarantees than control-flow integrity but at negligible cost.</li>
<li>An efficient compiler-based implementation of CPI and CPS for unmodified C/C++ code.</li>
<li>The first practical and complete OS distribution (based on FreeBSD) with full protection built-in against control-flow hijack attacks. In the rest of the paper we introduce our threat model (§2), describe CPI and CPS (§3), present our implementation (§4), evaluate our approach (§5), discuss related work (§6), and conclude (§7). We formalize the CPI enforcement mechanism and provide a sketch of its correctness proof in Appendix A.</li>
</ol>
<p>我们的实验评估表明，我们提出的方法施加了足够低的开销，可以在生产中部署。例如，CPS在SPEC CPU2006中的C程序上平均产生1.2％的开销，而在所有C / C ++程序上产生1.9％的平均开销。 C程序的CPI平均开销为2.9％，而所有C / C ++ SPEC CPU2006程序的CPI开销为8.4％。 CPI和CPS有效：它们可以防止RIPE基准测试中的100％攻击以及最近绕过CFI，ASLR，DEP和所有其他Microsoft Windows保护的攻击[19、15、9]。我们使用CPI / CPS编译并运行了完整的FreeBSD发行版以及≥100个广泛使用的软件包，这表明该方法是可行的。本文做出了以下贡献：</p>
<ol>
<li>定义了两个新的程序属性，它们提供了优于现有技术的安全性与执行成本之比：代码指针完整性（CPI）确保控制流不会通过内存错误被劫持，并且代码指针分离（ CPS）提供了比控制流完整性更强的安全性保证，但成本却微不足道。</li>
<li>针对未经修改的C / C ++代码的CPI和CPS的基于编译器的高效实现。</li>
<li>首次实用，完整的OS发行版（基于FreeBSD），并内置了针对控制流劫持攻击的全面保护。在本文的其余部分中，我们介绍了威胁模型（§2），描述了CPI和CPS（§3），介绍了我们的实施（§4），评估了我们的方法（§5），讨论了相关工作（§6），以及结论（第7节）。我们正式制定了CPI执行机制，并在附录A中提供了其正确性证明的草图。</li>
</ol>
<h3 id="Threat-Model"><a href="#Threat-Model" class="headerlink" title="Threat Model"></a>Threat Model</h3><p>This paper is concerned solely with control-flow hijack attacks, namely ones that give the attacker control of the instruction pointer. The purpose of this type of attack is to divert control flow to a location that would not otherwise be reachable in that same context, had the program not been compromised. Examples of such attacks include forcing a program to jump (i) to a location where the attacker injected shell code, (ii) to the start of a chain of return-oriented program fragments (“gadgets”), or (iii) to a function that performs an undesirable action in the given context, such as calling system() with attackersupplied arguments. Data-only attacks, i.e., that modify or leak unprotected non-control data, are out of scope.</p>
<p>本文仅涉及控制流劫持攻击，即使攻击者控制指令指针的攻击。 这种攻击的目的是将控制流转移到如果程序未受到破坏的情况下在同一上下文中无法访问的位置。 此类攻击的示例包括强迫程序跳至（i）攻击者注入外壳程序代码的位置，（ii）跳到面向返回的程序片段（“小工具”）链的开头，或（iii）跳到 在给定上下文中执行不良操作的函数，例如使用攻击者提供的参数调用system（）。 仅数据攻击（即修改或泄漏不受保护的非控制数据）不在范围内。</p>
<p>We assume powerful yet realistic attacker capabilities: full control over process memory, but no ability to modify the code segment. Attackers can carry out arbitrary memory reads and writes by exploiting input-controlled memory corruption errors in the program. They cannot modify the code segment, because the corresponding pages are marked read-executable and not writable, and they cannot control the program loading process. These assumptions ensure the integrity of the original program code instrumented at compile time, and enable the program loader to safely set up the isolation between the safe and regular memory regions. Our assumptions are consistent with prior work in this area.</p>
<p>我们假设攻击者具有强大而现实的功能：完全控制进程内存，但不能修改代码段。 攻击者可以通过利用程序中输入控制的内存损坏错误来执行任意内存读取和写入操作。 它们不能修改代码段，因为相应的页面被标记为可执行和不可写的，并且它们无法控制程序的加载过程。 这些假设可确保在编译时检测到的原始程序代码的完整性，并使程序加载器能够安全地建立安全内存区域与常规内存区域之间的隔离。 我们的假设与该领域的先前工作是一致的。</p>
<h3 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h3><p>We now present the terminology used to describe our design, then define the code-pointer integrity property (§3.1), describe the corresponding enforcement mechanism (§3.2), and define a relaxed version that trades some security guarantees for performance (§3.3). We further formalize the CPI enforcement mechanism and sketch its correctness proof in Appendix A.</p>
<p>现在，我们介绍用于描述我们的设计的术语，然后定义代码指针完整性属性（第3.1节），描述相应的强制机制（第3.2节），并定义一个宽松的版本，该版本为性能进行一些安全保证（第3.3节） 。 我们进一步规范了CPI执行机制，并在附录A中概述了其正确性证明。</p>
<p>We say a pointer dereference is safe iff the memory it accesses lies within the target object on which the dereferenced pointer is based. A target object can either be a memory object or a control flow destination. By pointer dereference we mean accessing the memory targeted by the pointer, either to read/write it (for data pointers) or to transfer control flow to its location (for code pointers). A memory object is a language-specific unit of memory allocation, such as a global or local variable, a dynamically allocated memory block, or a sub-object of a larger memory object (e.g., a field in a struct). Memory objects can also be program-specific, e.g., when using custom memory allocators. A control flow destination is a location in the code, such as the start of a function or a return location. A target object always has a well defined lifetime; for example, freeing an array and allocating a new one with the same address creates a different object.</p>
<p>我们说指针取消引用是安全的，因为它访问的内存位于取消引用的指针所基于的目标对象之内。 目标对象可以是内存对象或控制流目标。 通过指针解除引用，我们的意思是访问指针所针对的内存，以对其进行读/写（对于数据指针）或将控制流转移到其位置（对于代码指针）。 存储器对象是特定于语言的存储器分配单元，例如全局或局部变量，动态分配的存储器块或较大的存储器对象的子对象（例如，结构中的字段）。 内存对象也可以是特定于程序的，例如在使用自定义内存分配器时。 控制流目的地是代码中的位置，例如功能的开始或返回位置。 目标对象始终具有明确定义的生存期。 例如，释放一个数组并分配一个具有相同地址的新数组会创建一个不同的对象。</p>
<p>We say a pointer is based on a target object X iff the pointer is obtained at runtime by (i) allocating X on the heap, (ii) explicitly taking the address of X, if X is allocated statically, such as a local or global variable, or is a control flow target (including return locations, whose addresses are implicitly taken and stored on the stack when calling a function), (iii) taking the address of a sub-object y of X (e.g., a field in the X struct), or (iv) computinga pointer expression (e.g., pointer arithmetic, array indexing, or simply copying a pointer) involving operands that are either themselves based on object X or are not pointers. This is slightly stricter version of C99’s “based on” definition: we ensure that each pointer is based on at most one object.</p>
<p>我们说一个指针是基于目标对象X的，前提是该指针是在运行时通过以下方式获得的：（i）在堆上分配X，（ii）如果X是静态分配的，则显式采用X的地址，例如局部或全局分配 变量，或者是控制流目标（包括返回位置，其返回地址在调用函数时被隐式获取并存储在堆栈中），（iii）获取X子对象y的地址（例如， X结构），或（iv）计算涉及其自身基于对象X或非指针的操作数的指针表达式（例如，指针算术，数组索引或简单地复制指针）。 这是C99的“基于”定义的较严格版本：我们确保每个指针最多基于一个对象。</p>
<p>The execution of a program is memory-safe iff all pointer dereferences in the execution are safe. A program is memory-safe iff all its possible executions (for all inputs) are memory-safe. This definition is consistent with the state of the art for C/C++, such as SoftBounds+CETS [34, 35]. Precise memory safety enforcement [34, 36, 25] tracks the based-on information for each pointer in a program, to check the safety of each pointer dereference according to the definition above; the detection of an unsafe dereference aborts the program.</p>
<p>程序的执行是内存安全的，前提是执行中的所有指针取消引用都是安全的。 如果程序的所有可能执行（对于所有输入）都是内存安全的，则它是内存安全的。 此定义与C / C ++的最新技术水平一致，例如SoftBounds + CETS [34，35]。 精确的内存安全执行[34、36、25]跟踪程序中每个指针的基础信息，以根据上面的定义检查每个指针取消引用的安全性； 检测到不安全的取消引用将中止程序。</p>
<h4 id="3-1-The-Code-Pointer-Integrity-CPI-Property"><a href="#3-1-The-Code-Pointer-Integrity-CPI-Property" class="headerlink" title="3.1 The Code-Pointer Integrity (CPI) Property"></a>3.1 The Code-Pointer Integrity (CPI) Property</h4><p>A program execution satisfies the code-pointer integrity property iff all its dereferences that either dereference or access sensitive pointers are safe. Sensitive pointers are code pointers and pointers that may later be used to access sensitive pointers. Note that the sensitive pointer definition is recursive, as illustrated in Fig. 1. According to case (iv) of the based-on definition above, dereferencing a pointer to a pointer will correspondingly propagate the based-on information; e.g., an expression *p = &amp;q copies the result of &amp;q, which is a pointer based on q, to a location pointed to by p, and associates the basedon metadata with that location. Hence, the integrity of the based-on metadata associated with sensitive pointers requires that pointers used to update sensitive pointers be sensitive as well (we discuss implications of relaxing this definition in §3.3). The notion of a sensitive pointer is dynamic. For example, a void* pointer 2 in Fig. 1 is sensitive when it points at another sensitive pointer at run time, but it is not sensitive when it points to an integer.</p>
<img src="/img/CPI/fig1.png">

<p>如果程序的所有取消引用都是安全的，则程序执行将满足代码指针的完整性属性。敏感指针是代码指针和以后可用于访问敏感指针的指针。注意，敏感指针定义是递归的，如图1所示。根据上面的基于定义的情况（iv），将指针解引用为指针将相应地传播基于信息；因此，将指针解引用为指针是可行的。例如，表达式* p =＆q将基于q的指针＆q的结果复制到p指向的位置，并将基于基础的元数据与该位置相关联。因此，与敏感指针相关联的基于元数据的完整性要求用于更新敏感指针的指针也必须是敏感的（我们将在§3.3中讨论放宽此定义的含义）。敏感指针的概念是动态的。例如，图1中的void *指针2在运行时指向另一个敏感指针时，它是敏感的，但是当指向整数时，它是不敏感的。</p>
<p>A memory-safe program execution trivially satisfies the CPI property, but memory-safety instrumentation typically has high runtime overhead, e.g., ≥ 2× in stateof-the-art implementations [35]. Our observation is that only a small subset of all pointers are responsible for making control-flow transfers, and so, by enforcing memory safety only for control-sensitive data (and thus incurring no overhead for all other data), we obtain important security guarantees while keeping the cost of enforcement low. This is analogous to the controlplane/data-plane separation in network routers and modern servers [5], with CPI ensuring the safety of data that influences, directly or indirectly, the control plane.</p>
<p>内存安全程序的执行可以轻松满足CPI属性，但是内存安全工具通常具有较高的运行时开销，例如，在最新的实现中，≥2倍[35]。 我们的观察结果是，所有指针中只有一小部分负责进行控制流传输，因此，通过仅对控制敏感的数据强制执行内存安全性（因此不会为所有其他数据产生开销），我们获得了重要的安全保证。 同时保持较低的执行成本。 这类似于网络路由器和现代服务器中控制平面/数据平面的分离[5]，CPI确保直接或间接影响控制平面的数据的安全性。</p>
<p>Determining precisely the set of pointers that are sensitive can only be done at run time. However, the CPI property can still be enforced using any overapproximation of this set, and such over-approximations can be obtained at compile time, using static analysis.</p>
<p>仅在运行时才能确定敏感的指针集。 但是，仍可以使用此集合的任何过度逼近来实施CPI属性，并且可以使用静态分析在编译时获得这种过度逼近。</p>
<h4 id="3-2-The-CPI-Enforcement-Mechanism"><a href="#3-2-The-CPI-Enforcement-Mechanism" class="headerlink" title="3.2 The CPI Enforcement Mechanism"></a>3.2 The CPI Enforcement Mechanism</h4><p>We now describe a way to retrofit the CPI property into a program P using a combination of static instrumentation and runtime support. Our approach consists of a static analysis pass that identifies all sensitive pointers in P and all instructions that operate on them (§3.2.1), an instrumentation pass that rewrites P to “protect” all sensitive pointers, i.e., store them in a separate, safe memory region and associate, propagate, and check their based-3150 11th USENIX Symposium on Operating Systems Design and Implementation (OSDI ’14) USENIX Association on metadata (§3.2.2), and an instruction-level isolation mechanism that prevents non-protected memory operations from accessing the safe region (§3.2.3). For performance reasons, we handle return addresses stored on the stack separately from the rest of the code pointers using a safe stack mechanism (§3.2.4).</p>
<p>现在，我们描述一种使用静态工具和运行时支持的组合将CPI属性重新装配到程序P中的方法。 我们的方法包括一个静态分析过程，该过程识别P中的所有敏感指针以及对其进行操作的所有指令（第3.2.1节），以及一个仪表过程，重写P以“保护”所有敏感指针，即将它们存储在单独的位置。 ，安全内存区域，并关联，传播和检查其基于3150年第11届USENIX操作系统设计和实现研讨会（OSDI ‘14）USENIX元数据关联（§3.2.2），以及一种指令级隔离机制，可防止 -受保护的内存操作无法访问安全区域（第3.2.3节）。 出于性能原因，我们使用安全的堆栈机制（第3.2.4节）与其他代码指针分开处理存储在堆栈中的返回地址。</p>
<h4 id="3-2-1-CPI-Static-Analysis"><a href="#3-2-1-CPI-Static-Analysis" class="headerlink" title="3.2.1 CPI Static Analysis"></a>3.2.1 CPI Static Analysis</h4><p>We determine the set of sensitive pointers using typebased static analysis: a pointer is sensitive if its type is sensitive. Sensitive types are: pointers to functions, pointers to sensitive types, pointers to composite types (such as struct or array) that contains one or more members of sensitive types, or universal pointers (i.e., void*, char* and opaque pointers to forward-declared structs or classes). A programmer could additionally indicate, if desired, other types to be considered sensitive, such as struct ucred used in the FreeBSD kernel to store process UIDs and jail information. All code pointers that a compiler or runtime creates implicitly (such as return addresses, C++ virtual table pointers, and setjmp buffers) are sensitive as well.</p>
<p>我们使用基于类型的静态分析来确定敏感指针的集合：如果指针的类型是敏感的，则它是敏感的。 敏感类型是：指向函数的指针，敏感类型的指针，包含一个或多个敏感类型成员的复合类型的指针（例如struct或array），或通用指针（即void *，char *和不透明的指针） -声明的结构或类）。 如果需要，程序员还可以指示其他类型，例如FreeBSD内核中用于存储进程UID和监狱信息的结构。 编译器或运行时隐式创建的所有代码指针（例如返回地址，C ++虚拟表指针和setjmp缓冲区）也是敏感的。</p>
<p>Once the set of sensitive pointers is determined, we use static analysis to find all program instructions that manipulate these pointers. These instructions include pointer dereferences, pointer arithmetic, and memory (de-)allocation operations that calls to either (i) corresponding standard library functions, (ii) C++ new/delete operators, or (iii) manually annotated custom allocators.</p>
<p>确定敏感指针集后，我们将使用静态分析来查找所有可操纵这些指针的程序指令。 这些指令包括指针取消引用，指针算术和内存（取消）分配操作，这些操作调用（i）相应的标准库函数，（ii）C ++新建/删除运算符或（iii）手动注释的自定义分配器。</p>
<p>The derived set of sensitive pointers is overapproximate: it may include universal pointers that never end up pointing to sensitive values at runtime. For instance, the C/C++ standard allows char* pointers to point to objects of any type, but such pointers are also used for C strings. As a heuristic, we assume that char* pointers that are passed to the standard libc string manipulation functions or that are assigned to point to string constants are not universal. Neither the over-approximation nor the char* heuristic affect the security guarantees provided by CPI: over-approximation merely introduces extra overhead, while heuristic errors may result in false violation reports (though we never observed any in practice).</p>
<p>派生的敏感指针集过于近似：它可能包含通用指针，这些指针永远不会在运行时指向敏感值。 例如，C / C ++标准允许char *指针指向任何类型的对象，但此类指针也用于C字符串。 作为一种启发式方法，我们假定传递给标准libc字符串操作函数或分配给指向字符串常量的char *指针不是通用的。 过度逼近和char *启发式方法都不会影响CPI提供的安全性保证：过度逼近仅会引入额外的开销，而启发式错误可能会导致错误的违规报告（尽管实际上我们从未观察到）。</p>
<p>Memory manipulation functions from libc, such as memset or memcpy, could introduce a lot of overhead in CPI: they take void* arguments, so a libc compiled with CPI would instrument all accesses inside the functions, regardless of whether they are operating on sensitive data or not. CPI’s static analysis instead detects such cases by analyzing the real types of the arguments prior to being cast to void*, and the subsequent instrumentation pass handles them separately using type-specific versions of the corresponding memory manipulation functions.</p>
<p>来自libc的内存操作函数（例如memset或memcpy）可能会在CPI中引入大量开销：它们采用void *参数，因此使用CPI编译的libc会检测函数内部的所有访问，无论它们是否对敏感数据进行操作 或不。 CPI的静态分析通过在将参数转换为void *之前分析参数的真实类型来检测此类情况，随后的检测过程使用相应的内存操作函数的特定于类型的版本分别处理它们。</p>
<p>We augmented type-based static analysis with a dataflow analysis that handles most practical cases of unsafe pointer casts and casts between pointers and integers. If a value v is ever cast to a sensitive pointer type within the function being analyzed, or is passed as an argument or returned to another function where it is cast to a sensitive pointer, the analysis considers v to be sensitive as well. This analysis may fail when the data flow between v and its cast to a sensitive pointer type cannot be fully recovered statically, which might cause false violation reports (we have not observed any during our evaluation). Such casts are a common problem for all pointer-based memory safety mechanisms for C/C++ that do not require source code modifications [34].<br>我们使用数据流分析增强了基于类型的静态分析，该数据流分析可以处理不安全指针强制转换以及指针与整数之间的强制转换的大多数实际情况。 如果将值v转换为要分析的函数中的敏感指针类型，或者将其作为参数传递或返回到另一个函数，然后将其转换为敏感指针，则分析也将v视为敏感的。 当v及其强制转换为敏感指针类型之间的数据流无法完全静态恢复时，此分析可能会失败，这可能会导致错误的违规报告（我们在评估过程中未观察到任何报告）。 对于所有不需要修改源代码的C / C ++基于指针的内存安全机制，此类强制转换都是一个常见问题。</p>
<p>A key benefit of CPI is its selectivity: the number of pointer operations deemed to be sensitive is a small fraction of all pointer operations in a program. As we show in §5, for SPEC CPU2006, the CPI type-based analysis identifies for instrumentation 6.5% of all pointer accesses; this translates into a reduction of performance overhead of 16 – 44× relative to full memory safety.</p>
<p>CPI的一个主要优点是它的选择性：被认为是敏感的指针操作的数量只是程序中所有指针操作的一小部分。 正如我们在§5中所显示的，对于SPEC CPU2006，基于CPI类型的分析确定了所有指针访问的6.5％用于检测。 相对于完整的内存安全性，这意味着性能开销减少了16 – 44倍。</p>
<p>Nevertheless, we still think CPI can benefit from more sophisticated analyses. CPI can leverage any kind of points-to static analysis, as long as it provides an overapproximate set of sensitive pointers. For instance, when extending CPI to also protect select non-code-pointer data, we think DSA [27, 28] could prove more effective.</p>
<p>尽管如此，我们仍然认为CPI可以从更复杂的分析中受益。 CPI可以利用任何类型的指向静态的分析，只要它提供了一组过于近似的敏感指针。 例如，当扩展CPI以保护选定的非代码指针数据时，我们认为DSA [27，28]可能更有效。</p>
<h4 id="3-2-2-CPI-Instrumentation"><a href="#3-2-2-CPI-Instrumentation" class="headerlink" title="3.2.2 CPI Instrumentation"></a>3.2.2 CPI Instrumentation</h4><p>CPI instruments a program in order to (i) ensure that all sensitive pointers are stored in a safe region, (ii) create and propagate metadata for such pointers at runtime, and (iii) check the metadata on dereferences of such pointers.</p>
<p>CPI对程序进行检测，以便（i）确保所有敏感指针都存储在安全区域中；（ii）在运行时为此类指针创建和传播元数据；以及（iii）在取消引用此类指针时检查元数据。</p>
<p>In terms of memory layout, CPI introduces a safe region in addition to the regular memory region (Fig. 2). Storage space for sensitive pointers is allocated in both the safe region (the safe pointer store) and the regular region (as usual); one of the two copies always remains unused. This is necessary for universal pointers (e.g., void*), which could be stored in either region depending on whether they are sensitive at run time or not, and also helps to avoid some compatibility issues that arise from the change in memory layout. The address in regular memory is used as an offset to to look up the value of a sensitive pointer in the safe pointer store.</p>
<p>在内存布局方面，CPI除了常规内存区域之外还引入了安全区域（图2）。 敏感指针的存储空间在安全区域（安全指针存储）和常规区域（通常）中分配； 两个副本之一始终保持未使用状态。 这对于通用指针（例如void *）是必需的，它可以根据它们在运行时是否敏感而存储在任一区域中，并且还有助于避免由于内存布局更改而引起的某些兼容性问题。 常规存储器中的地址用作偏移量，以在安全指针存储中查找敏感指针的值。</p>
<p>The safe pointer store maps the address &amp;p of sensitive pointer p, as allocated in the regular region, to the value of p and associated metadata. The metadata for p describes the target object on which p is based: lower and upper address bounds of the object, and a temporal id (see Fig. 2). The layout of the safe pointer store is similar to metadata storage in SoftBounds+CETS [35], except that CPI also stores the value of p in the safe pointer store. Combined with the isolation of the safe region (§3.2.3), this allows CPI to guarantee full memory safety of all sensitive pointers without having to instrument all pointer operations.</p>
<img src="/img/CPI/fig2.png">

<p>安全指针存储将在常规区域中分配的敏感指针p的地址＆p映射到p的值和关联的元数据。 p的元数据描述了p所基于的目标对象：对象的上下地址范围，以及时间ID（请参见图2）。 安全指针存储的布局类似于SoftBounds + CETS [35]中的元数据存储，不同之处在于CPI也将p的值存储在安全指针存储中。 结合安全区域的隔离（第3.2.3节），这使CPI可以保证所有敏感指针的完全内存安全，而不必检测所有指针操作。</p>
<p>The instrumentation step changes instructions that operate on sensitive pointers, as found by CPI’s static analysis, to create and propagate the metadata directly following the based-on definition in §3.1. Instructions that explicitly take addresses of a statically allocated memory object or a function, allocate a new object on the heap, or take an address of a sub-object are instrumented to create metadata that describe the corresponding object. Instructions that compute pointer expressions are instrumented to propagate the metadata accordingly. Instructions that load or store sensitive pointers to memory are replaced with CPI intrinsic instructions (§3.2.3) that load or store both the pointer values and their metadata from/to the safe pointer store. In principle, call and return instructions also store and load code pointers, and so would need to be instrumented, but we instead protect return addresses using a safe stack (§3.2.4).</p>
<p>检测步骤会更改对敏感指针进行操作的指令（由CPI的静态分析发现），以直接根据§3.1中的定义创建和传播元数据。 显式采用静态分配的内存对象或函数的地址，在堆上分配新对象或采用子对象的地址的指令均经过了处理，以创建描述相应对象的元数据。 计算指针表达式的指令用于相应地传播元数据。 加载或存储指向内存的敏感指针的指令被CPI固有指令（第3.2.3节）取代，后者从安全指针存储中加载或存储指针值及其元数据。 原则上，调用和返回指令还存储和加载代码指针，因此需要进行检测，但是我们改为使用安全堆栈来保护返回地址（第3.2.4节）。</p>
<p>Every dereference of a sensitive pointer is instrumented to check at runtime whether it is safe, using the metadata associated with the pointer being dereferenced. Together with the restricted access to the safe region, this results in precise memory safety for all sensitive pointers.</p>
<p>敏感指针的每个取消引用都将使用与被取消引用的指针关联的元数据在运行时检查其是否安全。 加上对安全区域的访问受限，这为所有敏感指针提供了精确的内存安全性。</p>
<p>Universal pointers (void* and char*) are stored in either the safe pointer store or the regular region, depending on whether they are sensitive at runtime or not. CPI instruments instructions that cast from non-sensitive to universal pointer types to assign special “invalid” metadata (e.g., with lower bound greater than the upper bound) for the resulting universal pointers. These pointers, as a result, would never be allowed to access the safe region. CPI intrinsics for universal pointers would only store a pointer in the safe pointer store if it had valid metadata, and only load it from the safe pointer store if it contained valid metadata for that pointer; otherwise, they would store/load from the regular region.</p>
<p>通用指针（void *和char *）存储在安全指针存储区或常规区域中，具体取决于它们在运行时是否敏感。 CPI工具将指令从非敏感类型转换为通用指针类型，以为结果通用指针分配特殊的“无效”元数据（例如，下限大于上限）。 结果，将永远不允许这些指针访问安全区域。 通用指针的CPI内在函数只有在具有有效元数据的情况下才将指针存储在安全指针存储中，并且仅在安全指针存储中包含该指针的有效元数据时才从安全指针存储中加载它。 否则，它们将从常规区域存储/加载。</p>
<p>CPI can be configured to simultaneously store protected pointers in both the safe pointer store and regular regions, and check whether they match when loading them. In this debug mode, CPI detects all attempts to hijack control flow using non-protected pointer errors; in the default mode, such attempts are silently prevented. This debug mode also provides better compatibility with non-instrumented code that may read protected pointers (for example, callback addresses) but not write them. Modern compilers contain powerful static analysis passes that can often prove statically that certain memory accesses are always safe. The CPI instrumentation pass precedes compiler optimizations, thus allowing them to potentially optimize away some of the inserted checks while preserving the security guarantees.</p>
<p>可以将CPI配置为在安全指针存储区和常规区域中同时存储受保护的指针，并在加载它们时检查它们是否匹配。 在此调试模式下，CPI使用非保护的指针错误检测所有劫持控制流的尝试； 在默认模式下，将无提示地阻止此类尝试。 此调试模式还与可能读取受保护的指针（例如，回调地址）但无法写入受保护的指针的非仪表代码更好地兼容。 现代编译器包含强大的静态分析通道，这些通道通常可以静态地证明某些内存访问始终是安全的。 CPI工具传递在编译器优化之前进行，因此使它们可以潜在地优化一些插入的检查，同时保留安全性保证。</p>
<h4 id="3-2-3-Isolating-the-Safe-Region"><a href="#3-2-3-Isolating-the-Safe-Region" class="headerlink" title="3.2.3 Isolating the Safe Region"></a>3.2.3 Isolating the Safe Region</h4><p>The safe region can only be accessed via CPI intrinsic instructions, and they properly handle pointer metadata and the safe stack (§3.2.4). The mechanism for achieving this isolation is architecture-dependent.</p>
<p>只能通过CPI内部指令访问安全区域，并且它们可以正确处理指针元数据和安全堆栈（第3.2.4节）。 实现这种隔离的机制取决于体系结构。</p>
<p>On x86-32, we rely on hardware segment protection. We make the safe region accessible through a dedicated segment register, which is otherwise unused, and configure limits for all other segment registers to make the region inaccessible through them. The CPI intrinsics are then turned into code that uses the dedicated register and ensures that no other instructions in the program use that register. The segment registers are configured by the program loader, whose integrity we assume in our threat model; we also prevent the program from reconfiguring the segment registers via system calls. None of the programs we evaluated use the segment registers. </p>
<p>在x86-32上，我们依靠硬件段保护。 我们通过专用段寄存器使安全区域可访问，否则该段将不使用，并为所有其他段寄存器配置限制以使它们无法通过该区域访问。 然后将CPI内在函数转换为使用专用寄存器的代码，并确保程序中没有其他指令使用该寄存器。 段寄存器由程序加载器配置，我们在威胁模型中假设其完整性。 我们还防止程序通过系统调用重新配置段寄存器。 我们评估的程序均未使用段寄存器。</p>
<p>On x86-64, CPI relies on the fact that no addresses pointing into the safe region are ever stored in the regular region. This architecture no longer enforces the segment limits, however it still provides two segment registers with configurable base addresses. Similarly to x86-32, we use one of these registers to point to the safe region, however, we choose the base address of the safe region at random and rely on preventing access to it through information hiding. Unlike classic ASLR though, our hiding is leak-proof: since the objects in the safe region are indexed by addresses allocated for them in the regular region, no addresses pointing into the safe region are ever stored in regular memory at any time during execution. The 48-bit address space of modern x86-64 CPUs makes guessing the safe region address impractical, because most failed guessing attempts would crash the program, and such frequent crashes can easily be detected by other means.</p>
<p>在x86-64上，CPI依赖于以下事实：常规区域中永远不会存储指向安全区域的地址。 该体系结构不再强制执行段限制，但仍提供两个具有可配置基地址的段寄存器。 与x86-32相似，我们使用这些寄存器之一来指向安全区域，但是，我们随机选择安全区域的基地址，并依靠防止通过信息隐藏来访问它。 但是，与经典的ASLR不同，我们的隐藏是防泄漏的：由于安全区域中的对象是通过在常规区域中为其分配的地址来索引的，因此在执行过程中，随时都不会将指向安全区域的地址存储在常规存储器中。 现代x86-64 CPU的48位地址空间使猜测安全区域地址变得不切实际，因为大多数失败的猜测尝试都会使程序崩溃，并且可以通过其他方式轻松检测到此类频繁崩溃。</p>
<p>Other architectures could use randomization-based protection as well, or rely on precise software fault isolation (SFI) [11]. SFI requires that all memory operations in a program are instrumented, but the instrumentation is lightweight: it could be as small as a single and operation if the safe region occupies the entire upper half of the address space of a process. In our experiments, the additional overhead introduced by SFI was less than 5%.<br>其他体系结构也可以使用基于随机化的保护，或者依赖于精确的软件故障隔离（SFI）[11]。 SFI要求对程序中的所有内存操作进行检测，但是检测是轻量级的：如果安全区域占据了进程地址空间的整个上半部分，则它可以小到一个操作。 在我们的实验中，SFI引入的额外开销不到5％。</p>
<p>Since sensitive pointers form a small fraction of all data stored in memory, the safe pointer store is highly sparse. To save memory, it can be organized as a hash ta- 5152 11th USENIX Symposium on Operating Systems Design and Implementation (OSDI ’14) USENIX Association ble, a multi-level lookup table, or as a simple array relying on the sparse address space support of the underlying OS. We implemented and evaluated all three versions, and we discuss the fastest choice in §4.</p>
<p>由于敏感指针仅占内存中所有数据的一小部分，因此安全指针存储非常稀疏。 为了节省内存，可以将其组织为哈希表-5152第11届USENIX操作系统设计和实现专题讨论会（OSDI ‘14）USENIX关联表，多级查找表或依赖于稀疏地址空间的简单数组。 支持底层操作系统。 我们实现并评估了这三个版本，并讨论了§4中最快的选择。</p>
<p>In the future, we plan to leverage Intel MPX [24] for implementing the safe region, as described in §4.</p>
<p>将来，我们计划如第4节所述，利用英特尔MPX [24]来实现安全区域。</p>
<h4 id="3-2-4-The-Safe-Stack"><a href="#3-2-4-The-Safe-Stack" class="headerlink" title="3.2.4 The Safe Stack"></a>3.2.4 The Safe Stack</h4><p>CPI treats the stack specially, in order to reduce performance overhead and complexity. This is primarily because the stack hosts values that are accessed frequently, such as return addresses that are code pointers accessed on every function call, as well as spilled registers (temporary values that do not fit in registers and compilers store on the stack). Furthermore, tracking which of these values will end up at run time in memory (and thus need to be protected) vs. in registers is difficult, as the compiler decides which registers to spill only during late stages of code generation, long after CPI’s instrumentation pass.</p>
<p>CPI特别对待堆栈，以减少性能开销和复杂性。 这主要是因为堆栈包含经常访问的值，例如返回地址（在每个函数调用中访问的代码指针）以及溢出的寄存器（不适用于寄存器和编译器的临时值存储在堆栈中）。 此外，很难跟踪这些值中的哪个值将在运行时最终在内存中（因此需要受到保护）与寄存器相比较，因为编译器决定仅在代码生成的后期才对哪些寄存器进行溢出（CPI测试之后很长时间才溢出）。 通过。</p>
<p>A key observation is that the safety of most accesses to stack objects can be checked statically during compilation, hence such accesses require no runtime checks or metadata. Most stack frames contain only memory objects that are accessed exclusively within the corresponding function and only through the stack pointer register with a constant offset. We therefore place all such proven-safe objects onto a safe stack located in the safe region. The safe stack can be accessed without any checks. For functions that have memory objects on their stack that do require checks (e.g., arrays or objects whose address is passed to other functions), we allocate separate stack frames in the regular memory region. In our experience, less than 25% of functions need such additional stack frames (see Table 2). Furthermore, this fraction is much smaller among short functions, for which the overhead of setting up the extra stack frame is non-negligible.</p>
<p>一个关键的观察是，在编译期间可以静态检查大多数对堆栈对象的访问的安全性，因此此类访问不需要运行时检查或元数据。 大多数堆栈帧仅包含仅在相应功能内并且仅通过具有恒定偏移量的堆栈指针寄存器访问的存储器对象。 因此，我们将所有此类经过验证的安全对象放置在安全区域中的安全堆栈上。 无需任何检查即可访问安全堆栈。 对于其堆栈上确实需要检查的内存对象的函数（例如，将地址传递给其他函数的数组或对象），我们在常规内存区域中分配单独的堆栈帧。 根据我们的经验，只有不到25％的功能需要这种额外的堆栈框架（请参见表2）。 此外，在短函数中，这一部分要小得多，因此，建立额外堆栈帧的开销是不可忽略的。</p>
<p>The safe stack mechanism consists of a static analysis pass, an instrumentation pass, and runtime support. The analysis pass identifies, for every function, which objects in its stack frame are guaranteed to be accessed safely and can thus be placed on the safe stack; return addresses and spilled registers always satisfy this criterion. For the objects that do not satisfy this criterion, the instrumentation pass inserts code that allocates a stack frame for these objects on the regular stack. The runtime support allocates regular stacks for each thread and can be implemented either as part of the threading library, as we did on FreeBSD, or by intercepting thread create/destroy, as we did on Linux. CPI stores the regular stack pointer inside the thread control block, which is pointed to by one of the segment registers and can thus be accessed with a single memory read or write.</p>
<p>安全堆栈机制包括静态分析过程，检测过程和运行时支持。 对于每个功能，分析过程都可以确定其堆栈框架中的哪些对象可以安全访问，并可以放置在安全堆栈中； 返回地址和溢出的寄存器始终满足此条件。 对于不满足此条件的对象，检测过程将插入代码，这些代码为常规堆栈上的这些对象分配堆栈帧。 运行时支持为每个线程分配常规堆栈，并且可以像在FreeBSD上那样作为线程库的一部分来实现，也可以像在Linux上那样通过拦截线程创建/销毁来实现。 CPI将常规堆栈指针存储在线程控制块内部，该指针由段寄存器之一指向，因此可以通过单个存储器读取或写入操作来访问。</p>
<p>Our safe stack layout is similar to double stack approaches in ASR [6] and XFI [18], which maintain a separate stack for arrays and variables whose addresses are taken. However, we use the safe stack to enforce the CPI property instead of implementing software fault isolation. The safe stack is also comparable to languagebased approaches like Cyclone [25] or CCured [36] that simply allocate these objects on the heap, but our approach has significantly lower performance overhead.</p>
<p>我们的安全堆栈布局类似于ASR [6]和XFI [18]中的双堆栈方法，它们为获取地址的数组和变量维护单独的堆栈。 但是，我们使用安全堆栈来实施CPI属性，而不是实施软件故障隔离。 安全堆栈也可以与基于语言的方法（如Cyclone [25]或CCured [36]）相提并论，这些方法仅在堆上分配这些对象，但是我们的方法的性能开销明显较低。</p>
<p>The safe stack can be employed independently from CPI, and we believe it can replace stack cookies [14] in modern compilers. By providing precise protection of all return addresses (which are the target of ROP attacks today), spilled registers, and some local variables, the safe stack provides substantially stronger security than stack cookies, while incurring equal or lower performance overhead and deployment complexity.</p>
<p>安全堆栈可以独立于CPI使用，我们相信它可以代替现代编译器中的堆栈cookie [14]。 通过对所有返回地址（当今成为ROP攻击的目标），溢出的寄存器和某些局部变量提供精确的保护，安全堆栈提供的安全性远高于堆栈cookie，同时产生相等或更低的性能开销和部署复杂性。</p>
<h4 id="3-3-Code-Pointer-Separation-CPS"><a href="#3-3-Code-Pointer-Separation-CPS" class="headerlink" title="3.3 Code-Pointer Separation (CPS)"></a>3.3 Code-Pointer Separation (CPS)</h4><p>The code-pointer separation property trades some of CPI’s security guarantees for reduced runtime overhead. This is particularly relevant to C++ programs with many virtual functions, where the fraction of sensitive pointers instrumented by CPI can become high, since every pointer to an object that contains virtual functions is sensitive. We found that, on average, CPS reduces overhead by 4.3× (from 8.4% for CPI down to 1.9% for CPS), and in some cases by as much as an order of magnitude.</p>
<p>安全堆栈可以独立于CPI使用，我们相信它可以代替现代编译器中的堆栈cookie [14]。 通过对所有返回地址（当今成为ROP攻击的目标），溢出的寄存器和某些局部变量提供精确的保护，安全堆栈提供的安全性远高于堆栈cookie，同时产生相等或更低的性能开销和部署复杂性。</p>
<p>CPS further restricts the set of protected pointers to code pointers only, leaving pointers that point to code pointers uninstrumented. We additionally restrict the definition of based-on by requiring that a code pointer be based only on a control flow destination. This restriction prevents attackers from “forging” a code pointer from a value of another type, but still allows them to trick the program into reading or updating wrong code pointers.</p>
<p>CPS进一步将受保护的指针集限制为仅代码指针，而使指向代码指针的指针不被插入。 我们还通过要求代码指针仅基于控制流目的地来限制基于定义。 此限制可防止攻击者从另一种类型的值“伪造”代码指针，但仍允许他们诱骗程序读取或更新错误的代码指针。</p>
<p>CPS is enforced similarly to CPI, except (i) for the criteria used to identify sensitive pointers during static analysis, and (ii) that CPS does not need any metadata. Control-flow destinations (pointed to by code pointers) do not have bounds, because the pointer value must always match the destination exactly, hence no need for bounds metadata. Furthermore, they are typically static, hence do not need temporal metadata either (there are 6USENIX Association 11th USENIX Symposium on Operating Systems Design and Implementation (OSDI ’14) 153 a few rare exceptions, like unloading a shared library, which are handled separately). This reduces the size of the safe region and the number of memory accesses when loading or storing code pointers. If the safe region is organized as a simple array, a CPS-instrumented program performs essentially the same number of memory accesses when loading or storing code pointers as a noninstrumented one; the only difference is that the pointers are being loaded or stored from the safe pointer store instead of their original location (universal pointer load or store instructions still introduce one extra memory access per such instruction). As a result, CPS can be enforced with low performance overhead.</p>
<p>CPS的实施与CPI相似，但（i）用于在静态分析过程中标识敏感指针的标准，以及（ii）CPS不需要任何元数据。控制流目标（由代码指针指向）没有边界，因为指针值必须始终与目标完全匹配，因此不需要边界元数据。此外，它们通常是静态的，因此也不需要时态元数据（有6USENIX协会第11届USENIX操作系统设计与实现专题讨论会（OSDI ‘14）153一些极少数例外，例如卸载共享库，这些问题需要单独处理） 。这样可以减少安全区域的大小和加载或存储代码指针时的存储器访问次数。如果将安全区域组织成一个简单的数组，则在加载或存储代码指针时，使用CPS的程序执行与非使用仪表的代码本质上相同的内存访问次数。唯一的不同是，指针是从安全指针存储中加载或存储的，而不是从安全指针的原始位置加载或存储的（通用指针加载或存储指令仍会为此类指令引入一个额外的内存访问权限）。结果，可以以较低的性能开销执行CPS。</p>
<p>CPS guarantees that (i) code pointers can only be stored to or modified in memory by code pointer store instructions, and (ii) code pointers can only be loaded by code pointer load instructions from memory locations to which previously a code pointer store instruction stored a value. Combined with the safe stack, CPS precisely protects return addresses. CPS is stronger than most CFI implementations [1, 54, 53], which allow any vulnerable instruction in a program to modify any code pointer; they only check that the value of a code pointer (when used in an indirect control transfer) points to a function defined in a program (for function pointers) or directly follows a call instruction (for return addresses). CPS guarantee (i) above restricts the attack surface, while guarantee (ii) restricts the attacker’s flexibility by limiting the set of locations to which the control can be redirected—the set includes only entry points of functions whose addresses were explicitly taken by the program.</p>
<p>CPS保证（i）代码指针只能由代码指针存储指令存储到内存中或在内存中进行修改，并且（ii）代码指针只能由代码指针加载指令从先前存储了代码指针存储指令的存储位置加载一个值。结合安全堆栈，CPS可以精确地保护返回地址。 CPS比大多数CFI实现要强[1、54、53]，后者允许程序中的任何易受攻击的指令修改任何代码指针。它们仅检查代码指针的值（在间接控制传递中使用时）指向程序中定义的函数（对于函数指针）还是直接跟随调用指令（对于返回地址）。上面的CPS保证（i）限制了攻击面，而保证（ii）通过限制控件可以重定向到的位置集来限制攻击者的灵活性-该集合仅包含其地址由程序明确获取的功能的入口点。</p>
<p>To illustrate this difference, consider the case of the Perl interpreter, which implements its opcode dispatch by representing internally a Perl program as a sequence of function pointers to opcode handlers and then calling in its main execution loop these function pointers one by one. CFI statically approximates the set of legitimate control-flow targets, which in this case would include all possible Perl opcodes. CPS however permits only calls through function pointers that are actually assigned. This means that a memory bug in a CFI-protected Perl interpreter may permit an attacker to divert control flow and execute any Perl opcode, whereas in a CPS-protected Perl interpreter the attacker could at most execute an opcode that exists in the running Perl program.</p>
<p>为了说明这种差异，请考虑Perl解释器的情况，该解释器通过将Perl程序内部表示为操作码处理程序的功能指针序列，然后在其主执行循环中逐个调用这些功能指针，来实现其操作码分配。 CFI静态近似于合法控制流目标的集合，在这种情况下，它将包括所有可能的Perl操作码。 但是，CPS仅允许通过实际分配的函数指针进行调用。 这意味着受CFI保护的Perl解释器中的内存错误可能允许攻击者转移控制流并执行任何Perl操作码，而在受CPS保护的Perl解释器中，攻击者最多可以执行正在运行的Perl程序中存在的操作码 。</p>
<p>CPS provides strong control-flow integrity guarantees and incurs low overhead (§5). We found that it prevents all recent attacks designed to bypass CFI [19, 15, 9]. We consider CPS to be a solid alternative to CPI in those cases when CPI’s (already low) overhead seems too high.</p>
<p>CPS提供了强大的控制流完整性保证，并降低了开销（第5节）。 我们发现，它可以防止所有旨在绕过CFI的近期攻击[19，15，9]。 在CPI（已经很低）的开销似乎过高的情况下，我们认为CPS可以替代CPI。</p>
<h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p>We implemented a CPI/CPS enforcement tool for C/C++, called Levee, on top of the LLVM 3.3 compiler infrastructure [30], with modifications to LLVM libraries, the clang compiler, and the compiler-rt runtime. To use Levee, one just needs to pass additional flags to the compiler to enable CPI (-fcpi), CPS (-fcps), or safestack protection (-fstack-protector-safe). Levee works on unmodified programs and supports Linux, FreeBSD, and Mac OS X in both 32-bit and 64-bit modes. </p>
<p>我们在LLVM 3.3编译器基础结构[30]的基础上，为C / C ++实现了一个称为Levee的CPI / CPS实施工具，对LLVM库，clang编译器和compile-rt运行时进行了修改。 要使用Levee，只需要将其他标志传递给编译器即可启用CPI（-fcpi），CPS（-fcps）或安全堆栈保护（-fstack-protector-safe）。 Levee可以处理未修改的程序，并以32位和64位模式支持Linux，FreeBSD和Mac OSX。</p>
<p>Levee can be downloaded from the project homepage <a target="_blank" rel="noopener" href="http://levee.epfl.ch/">http://levee.epfl.ch</a>, and we plan to push our changes to the upstream LLVM.</p>
<p>可以从项目主页<a target="_blank" rel="noopener" href="http://levee.epfl.ch下载levee,我们计划将所做的更改推送到上游llvm./">http://levee.epfl.ch下载Levee，我们计划将所做的更改推送到上游LLVM。</a></p>
<p>Analysis and instrumentation passes: We implemented the static analysis and instrumentation for CPI as two LLVM passes, directly following the design from §3.2.1 and §3.2.2. The LLVM passes operate on the LLVM intermediate representation (IR), which is a lowlevel strongly-typed language-independent program representation tailored for static analyses and optimization purposes. The LLVM IR is generated from the C/C++ source code by clang, which preserves most of the type information that is required by our analysis, with a few corner cases. For example, in certain cases, clang does not preserve the original types of pointers that are cast to void* when passing them as an argument to memset or similar functions, which is required for the memsetrelated optimizations discussed in §3.2.2. The IR also does not distinguish between void* and char* (represents both as i8*), but this information is required for our string pointers detection heuristic. We augmented clang to always preserve such type information as LLVM metadata.</p>
<p>分析和检测过程：我们直接按照§3.2.1和§3.2.2的设计，通过两次LLVM遍历对CPI进行了静态分析和检测。 LLVM传递对LLVM中间表示（IR）进行操作，该中间表示是为静态分析和优化目的而量身定制的低级强类型独立于语言的程序表示。 LLVM IR由clang从C / C ++源代码生成，保留了我们分析所需要的大多数类型信息，并带有一些特殊情况。例如，在某些情况下，当将它们作为参数传递给memset或类似函数时，clang不会保留转换为void *的原始指针类型，这是第3.2.2节中讨论的与memset相关的优化所必需的。 IR也不区分void *和char *（均表示为i8 *），但是此信息对于我们的字符串指针检测启发式是必需的。我们扩展了clang以始终保留诸如LLVM元数据之类的类型信息。</p>
<p>Safe stack instrumentation pass: The safe stack instrumentation targets functions that contain on-stack memory objects that cannot be put on the safe stack. For such functions, it allocates a stack frame on the unsafe stack and relocates corresponding variables to that frame.</p>
<p>安全堆栈检测通道：安全堆栈检测通道针对包含不能放在安全堆栈上的堆栈内存对象的函数。 对于此类功能，它将在不安全的堆栈上分配一个堆栈框架，并将相应的变量重新定位到该框架。</p>
<p>Given that most of the functions do not need an unsafe stack, Levee uses the usual stack pointer (rsp register on x86-64) as the safe stack pointer, and stores the unsafe stack pointer in the thread control block, which is accessible directly through one of the segment registers. When needed, the unsafe stack pointer is loaded into an IR local value, and Levee relies on the LLVM register allocator to pick the register for the unsafe stack pointer. Levee explicitly encodes unsafe stack operations as IR instructions that manipulate an unsafe stack pointer; it leaves all operations that use a safe stack intact, letting the LLVM code generator manage them. Levee performs these changes as a last step before code generation (directly replacing LLVM’s stack-cookie protection pass), thus ensuring that it operates on the final stack layout.</p>
<p>鉴于大多数函数不需要不安全的堆栈，Levee使用常规的堆栈指针（x86-64上的rsp寄存器）作为安全堆栈指针，并将不安全的堆栈指针存储在线程控制块中，可通过以下方式直接访问 段寄存器之一。 必要时，将不安全堆栈指针加载到IR本地值中，并且Levee依赖LLVM寄存器分配器来选择不安全堆栈指针的寄存器。 Levee将不安全的堆栈操作显式编码为IR指令，以操作不安全的堆栈指针。 它将完整使用安全堆栈的所有操作保留下来，让LLVM代码生成器对其进行管理。 Levee进行了这些更改，这是代码生成之前的最后一步（直接替代LLVM的堆栈cookie保护通过），从而确保它可以在最终的堆栈布局上运行。</p>
<p>Certain low-level functions modify the stack pointer directly. These functions include setjmp/longjmp and exception handling functions (which store/load the stack pointer), and thread create/destroy functions, which allocate/free stacks for threads. On FreeBSD we provide 7154 11th USENIX Symposium on Operating Systems Design and Implementation (OSDI ’14) USENIX Association full-system CPI, so we directly modified these functions to support the dual stacks. On Linux, our instrumentation pass finds setjmp/longjmp and exception handling functions in the program and inserts required instrumentation at their call sites, while thread create/destroy functions are intercepted and handled by the Levee runtime.</p>
<p>某些低级函数直接修改堆栈指针。 这些功能包括setjmp / longjmp和异常处理功能（用于存储/加载堆栈指针），以及线程创建/销毁功能，用于为线程分配/释放堆栈。 在FreeBSD上，我们提供了7154次第11届USENIX操作系统设计和实现研讨会（OSDI ’14）USENIX协会的全系统CPI，因此我们直接修改了这些功能以支持双栈。 在Linux上，我们的检测过程可在程序中找到setjmp / longjmp和异常处理函数，并在其调用位置插入所需的检测，而线程创建/销毁函数则由Levee运行时拦截和处理。</p>
<p>Runtime support library: Most of the instrumentation by the above passes are added as intrinsic function calls, such as cpi ptr store() or cpi memcpy(), which are implemented by Levee’s runtime support library (a part of compiler-rt). This design cleanly separates the safe pointer store implementation from the instrumentation pass. In order to avoid the overhead associated with extra function calls, we ensure that some of the runtime support functions are always inlined. We compile these functions into LLVM bitcode and instruct clang to link this bitcode into every object file it compiles. Functions that are called rarely (e.g., cpi abort(), called when a CPI violation is detected) are never inlined, in order to reduce the instruction cache footprint of the instrumentation.</p>
<p>运行时支持库：上述过程中的大多数检测都是作为内在函数调用添加的，例如cpi ptr store（）或cpi memcpy（），这些功能是由Levee的运行时支持库（编译器rt的一部分）实现的。 此设计将安全指针存储的实现与检测过程完全分开。 为了避免与额外的函数调用相关的开销，我们确保始终内联某些运行时支持函数。 我们将这些函数编译为LLVM位代码，并指示clang将此位代码链接到它编译的每个目标文件中。 永远不会内联很少调用的函数（例如，在检测到CPI违规时调用的cpi abort（）），以减少工具的指令缓存占用空间。</p>
<p>We implemented and benchmarked several versions of the safe pointer store map in our runtime support library: a simple array, a two-level lookup table, and a hashtable. The array implementation relies on the sparse address space support of the underlying OS. Initially we found it to perform poorly on Linux, due to many page faults (especially at startup) and additional TLB pressure. Switching to superpages (2 MB on Linux) made this simple table the fastest implementation of the three.</p>
<p>我们在运行时支持库中实现了安全指针存储映射的几种版本并对其进行了基准测试：一个简单的数组，一个两级查找表和一个哈希表。 阵列实现依赖于底层OS的稀疏地址空间支持。 最初，由于许多页面错误（尤其是在启动时）和额外的TLB压力，我们发现它在Linux上的性能较差。 切换到超级页面（在Linux上为2 MB）使此简单表成为三个表中最快的实现。</p>
<p>Binary level functionality: Some code pointers in binaries are generated by the compiler and/or linker, and cannot be protected on the IR level. Such pointers include the ones in jump tables, exception handler tables, and the global offset table. Bounds checks for the jump tables and the exception handler tables are already generated by LLVM anyway, and the tables themselves are placed in read-only memory, hence cannot be overwritten. We rely on the standard loader’s support for read-only global offset tables, using the existing RTLD NOW flag.</p>
<p>二进制级别的功能：二进制代码中的某些代码指针是由编译器和/或链接器生成的，不能在IR级别上受到保护。 这样的指针包括跳转表，异常处理程序表和全局偏移表中的指针。 无论如何，LLVM已经生成了跳转表和异常处理程序表的边界检查，并且表本身被放置在只读存储器中，因此不能被覆盖。 我们使用现有的RTLD NOW标志，依靠标准加载程序对只读全局偏移表的支持。</p>
<p>Limitations: The CPI design described in §3 includes both spatial and temporal memory safety enforcement for sensitive pointers, however our current prototype implements spatial memory safety only. It can be easily extended to enforce temporal safety by directly applying the technique described in [35] for sensitive pointers.</p>
<p>局限性：§3中描述的CPI设计包括对敏感指针的空间和时间内存安全实施，但是我们当前的原型仅实现空间内存安全。 通过直接将[35]中描述的技术用于敏感指针，可以轻松地扩展它以增强时间安全性。</p>
<p>Levee currently supports Linux, FreeBSD and Mac OS user-space applications. We believe Levee can be ported to protect OS kernels as well. Related technical challenges include integration with the kernel memory management subsystem and handling of inline assembly.</p>
<p>Levee当前支持Linux，FreeBSD和Mac OS用户空间应用程序。 我们相信Levee也可以移植来保护OS内核。 相关的技术挑战包括与内核内存管理子系统的集成以及内联汇编的处理。</p>
<p>CPI and CPS require instrumenting all code that manipulates sensitive pointers; non-instrumented code can cause unnecessary aborts. Non-instrumented code could come from external libraries compiled without Levee, inline assembly, or dynamically generated code. Levee can be configured to simultaneously store sensitive pointers in both the safe and the regular regions, in which case non-instrumented code works fine as long as it only reads sensitive pointers but doesn’t write them.</p>
<p>CPI和CPS要求检测所有操纵敏感指针的代码。 非仪器代码可能导致不必要的中止。 非仪器代码可以来自未经Levee编译，没有内联汇编程序或动态生成的代码的外部库。 可以将Levee配置为在安全区域和常规区域中同时存储敏感指针，在这种情况下，非插入式代码可以正常工作，只要它只读取敏感指针但不写入敏感指针即可。</p>
<p>Inline assembly and dynamically generated code can still update sensitive pointers if instrumented with appropriate calls to the Levee runtime, either manually by a programmer or directly by the code generator.</p>
<p>如果用适当的对Levee运行时的调用进行检测，则内联汇编和动态生成的代码仍可以更新敏感指针，可以由程序员手动或由代码生成器直接进行。</p>
<p>Dynamically generated code (e.g., for JIT compilation) poses an additional problem: running the generated code requires making writable pages executable, which violates our threat model (this is a common problem for most control-flow integrity mechanisms). One solution is to use hardware or software isolation mechanisms to isolate the code generator from the code it generates.</p>
<p>动态生成的代码（例如，用于JIT编译）带来了另一个问题：运行生成的代码需要使可写页面可执行，这违反了我们的威胁模型（这是大多数控制流完整性机制的常见问题）。 一种解决方案是使用硬件或软件隔离机制将代码生成器与其生成的代码隔离。</p>
<p>Sensitive data protection: Even though the main focus of CPI is control-flow hijack protection, the same technique can be applied to protect other types of sensitive data. Levee can treat programmer-annotated data types as sensitive and protect them just like code pointers. CPI could also selectively protect individual program variables (as opposed to types), however it would require replacing the type-based static analysis described in §3.2.1 with data-based points-to analysis such as DSA [27, 28]. </p>
<p>敏感数据保护：尽管CPI的主要重点是控制流劫持保护，但是可以将相同的技术应用于保护其他类型的敏感数据。 Levee可以将程序员注释的数据类型视为敏感数据，并像代码指针一样保护它们。 CPI还可以选择性地保护单个程序变量（而不是类型），但是它需要用基于数据的指向分析（例如DSA）替换第3.2.1节中描述的基于类型的静态分析[27，28]。</p>
<p>Future MPX-based implementation: Intel announced a hardware extension, Intel MPX, to be used for hardware-enforced memory safety [23]. It is proposed as a testing tool, probably due to the associated overhead; no overhead numbers are available at the time of writing.</p>
<p>未来基于MPX的实现：英特尔宣布了硬件扩展，英特尔MPX，将用于硬件增强的内存安全性[23]。 建议将其作为测试工具，可能是由于相关的开销。 在撰写本文时，没有可用的间接费用号码。</p>
<p>We believe MPX (or similar) hardware can be repurposed to enforce CPI with lower performance overhead than our existing software-only implementation. MPX provides special registers to store bounds along with instructions to check them, and a hardware-based implementation of a pointer metadata store (analogous to the safe pointer store in our design), organized as a twolevel lookup table. Our implementation can be adapted to use these facilities once MPX-enabled hardware becomes available. We believe that a hardware-based CPI implementation can reduce the overhead of a softwareonly CPI in much the same way as HardBound [16] or Watchdog [33] reduced the overhead of SoftBound.</p>
<p>我们认为，与现有的仅软件实现相比，MPX（或类似）硬件可以重新配置为以较低的性能开销实施CPI。 MPX提供了特殊的寄存器来存储边界以及检查边界的指令，还提供了一个基于硬件的指针元数据存储（类似于我们设计中的安全指针存储）的实现，并组织为两级查找表。 一旦启用MPX的硬件可用，我们的实施方式便可以使用这些功能。 我们认为，基于硬件的CPI实现可以通过与HardBound [16]或Watchdog [33]减少SoftBound的开销几乎相同的方式减少仅软件CPI的开销。</p>
<p>Adopting MPX for CPI might require implementing metadata loading logic in software. Like CPI, MPX also stores the pointer value together with the metadata. However, being a testing tool, MPX chooses compatibility with non-instrumented code over security guarantees: it uses the stored pointer value to check whether the original pointer was modified by non-instrumented code and, if yes, resets the bounds to [0,∞]. In contrast, CPI’s guarantees depend on preventing any non-instrumented code from ever modifying sensitive pointer values.</p>
<p>为CPI采用MPX可能需要在软件中实现元数据加载逻辑。 与CPI一样，MPX还将指针值与元数据存储在一起。 但是，作为一种测试工具，MPX会选择与非仪表代码兼容的方式来确保安全性：它使用存储的指针值来检查原始指针是否被非仪表代码所修改，如果是，则将边界重置为[0， ∞]。 相反，CPI的保证取决于防止任何非仪表代码修改敏感指针值。</p>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>  Theme <a target="_blank" rel="noopener" href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


    <script>
        /**
         *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
         *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
        */
        if( '' || '')
        var disqus_config = function () {
            this.page.url = '';  // Replace PAGE_URL with your page's canonical URL variable
            this.page.identifier = ''; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
        };

        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document, s = d.createElement('script');
            s.src = 'https://airclouds-blog.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>



</html>
